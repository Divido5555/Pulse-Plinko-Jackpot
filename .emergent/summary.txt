<analysis>
The project is now a live, mainnet-ready PulseChain dApp: the **PLS369 DAO • PulseChain Plinko Jackpot**.

Earlier iterations explored:
- Pionex trading dashboards
- PLS-denominated Plinko prototypes
- Oracle-based randomness
- A demo-only physics board with mock data

All of that has now been consolidated into a single, production-focused system with:

- A fixed-supply **PLS369** ERC-20 token on PulseChain
- A deployed **PlinkoGame369mnV1** contract that:
  - Accepts only PLS369
  - Uses fully on-chain randomness (no Fetch / no external oracle)
  - Implements main + mini jackpot logic and prize multipliers
  - Supports a “finalize” lock that makes parameters immutable for production
- A React/TypeScript frontend (in `/frontend`) themed as:
  **“Pulse369 DAO • PulseChain Plinko Jackpot”**

The frontend already implements:
- A full-width Plinko board with a draggable puck
- Physics-style visual behavior (staggered pegs, visual bounces)
- Side panels showing jackpots, balance, and game stats
- A session-layer wallet + P/L tracker (for demo mode)

The focus going forward is **not** to reinvent the game rules, but to:
- Align the UI state machine with the *on-chain* game
- Replace all mock/demo state with real contract reads and writes
- Reflect the finalized tokenomics (PLS369 entry, jackpots, DAO/Dev accrual) everywhere in the UI and docs.
</analysis>

<product_requirements>
Goal: Deliver a production-ready, on-chain Plinko jackpot dApp for **PLS369 DAO** on PulseChain.

**Core Gameplay**
- Network: PulseChain mainnet
- Token: PLS369 (fixed supply, 18 decimals)
- Contracts (current deployment):
  - PLS369 token: `0x55aC731aAa3442CE4D8bd8486eE4521B1D6Af5EC`
  - Plinko game: `0xFBF81bFA463252e25C8883ac0E3EBae99617A52c`
- Entry price: `ENTRY_PRICE = 10 PLS369` (read from `getGameState()`)
- Flow:
  1. User connects a PulseChain wallet.
  2. UI prompts for `approve(gameAddress, ENTRY_PRICE)` if needed.
  3. User clicks **Play** (or drags+releases the puck), which calls `play()`.
  4. UI displays the resulting slot, prize, and updated jackpot values.

**Tokenomics & Jackpots (high level)**
- Every play:
  - Pulls 10 PLS369 from the player via `transferFrom`.
  - Splits that entry into:
    - Main jackpot increment
    - Mini jackpot increment
    - DAO rewards
    - Dev rewards
    - Immediate prize payouts (for multiplier slots)
- Main jackpot:
  - Triggered when `slot == MAIN_SLOT` *and* `randomness % mainJackpotOdds == 0`.
  - Payout split between winner, DAO, and jackpot reset.
- Mini jackpot:
  - Triggered on specific mini slots (e.g. `2` or `16`) with `randomness % miniJackpotOdds == 0`.
  - Payout split between winner, dev, and jackpot reset.
- House edge is small but positive for the DAO over time.

**Frontend & UX**
- Theme: Dark, neon “Pulse369 DAO” style (current design is good).
- Board:
  - 20-slot bottom row, with a properly staggered peg layout.
  - Puck starts from a highlighted “drop” zone, then falls visually.
- Right-side panel shows:
  - User’s PLS369 balance (on-chain)
  - Current session stats (games played, wins, P/L in PLS369)
  - Main and mini jackpot sizes (from contract)
- Results banner:
  - Shows the landed slot, multiplier, and any jackpot wins.
- Demo mode (optional):
  - For pre-launch or no-wallet users, use a purely local simulation mode with fake balance.
</product_requirements>

<key_technical_concepts>
- **Frontend**
  - React + TypeScript
  - State management via React hooks (no global state library required yet)
  - CSS / Tailwind / custom styles for neon / starfield theming
- **Smart Contracts (on PulseChain)**
  - `PLS369` ERC-20 token
  - `PlinkoGame369mnV1` game contract:
    - On-chain randomness via `keccak256` over `block.prevrandao`, `block.timestamp`, `msg.sender`, and `playCount`.
    - Jackpot + prize logic, DAO/Dev accrual, and `finalize()` lock.
- **Wallet Integration**
  - Ethers.js / viem / wagmi (choice is flexible)
  - Must support:
    - Network detection (PulseChain)
    - `approve()` on PLS369
    - `play()` on PlinkoGame369
- **Game Physics Layer**
  - The visual puck animation is client-side only.
  - The *authoritative* result comes from the contract’s `play()` transaction.
  - The UI should map the on-chain slot index to:
    - The visual slot at the bottom
    - A payout/multiplier label
</key_technical_concepts>

<code_architecture>
The application is a full-stack dApp, but the backend is minimal (primarily static serving + optional analytics). The core trust and logic live on-chain.

**High-Level Layout**

- `/contracts`
  - `PLS369.sol` — fixed-supply ERC-20.
  - `PlinkoGame369mnV1.sol` — live game contract used in production.
- `/frontend`
  - React app for the Plinko game UI.
  - Key components:
    - `GamePage` / `App` — top-level route that wires wallet, game state, and layout.
    - `PlinkoBoard` — renders the pegs, slots, and the animated puck.
    - `JackpotPanel` — shows main/mini jackpots from `getGameState()`.
    - `WalletPanel` — shows user PLS369 balance and session stats.
    - `ResultBanner` — shows last outcome (win, loss, jackpot).
- `/docs`
  - Whitepaper + tokenomics and economics docs.
- `/tests`
  - Solidity tests (jackpot odds, payout correctness, access control).

**Important Notes for Emergent**
- The **old PLS 10,000 entry game and Fetch randomness are deprecated**.
- The **only authoritative game** is `PlinkoGame369mnV1` using PLS369 and on-chain randomness.
- Physics board and in-browser jackpots are purely **view/UX**, not game logic.
</code_architecture>

<pending_tasks>
- **Wallet wiring**
  - Replace any mock balance with actual PLS369 balance from the connected wallet.
  - Implement `approve()` + `play()` button flow.
- **Game state sync**
  - Wire `getGameState()` to:
    - Main and mini jackpot displays.
    - DAO and Dev accrued amounts (for an “Economics / House Edge” panel).
- **Result mapping**
  - After `play()` transaction succeeds:
    - Read emitted events or return data to get the final slot and payout.
    - Animate the puck into the correct bottom slot.
- **Error handling**
  - Handle:
    - Wrong network (not PulseChain)
    - Insufficient PLS369 balance
    - Missing allowance
    - Transaction rejection / failure
- **Post-finalize checklist**
  - Once `finalize()` is called on-chain, ensure the UI:
    - Hides/locks any admin-only controls.
    - Reflects the immutable nature of odds and multipliers.
</pending_tasks>

<current_work>
We are in the **integration and polish phase**:

- Contracts are live and tested on PulseChain.
- Frontend visuals and physics are largely complete.
- Whitepaper and docs have been updated to the PLS369-only model.

What still needs doing is connecting the existing, polished UI to the real on-chain game: move from “beautiful demo” to “fully live dApp” by wiring wallet, contract calls, and real-time state.
</current_work>

<optional_next_step>
Implement the full **wallet → approve → play → update UI** pipeline on the frontend using the deployed PulseChain contracts. Once that’s stable, add a small “developer console” panel that shows raw `getGameState()` data for debugging jackpot and accrual behavior.
</optional_next_step>

